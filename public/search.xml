<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DASCTF 2024暑期挑战赛复现</title>
      <link href="/2024/07/21/DASCTF-2024%E6%9A%91%E6%9C%9F%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
      <url>/2024/07/21/DASCTF-2024%E6%9A%91%E6%9C%9F%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="DASCTF-2024暑期挑战赛"><a href="#DASCTF-2024暑期挑战赛" class="headerlink" title="DASCTF 2024暑期挑战赛"></a>DASCTF 2024暑期挑战赛</h3><h4 id="complex-enc"><a href="#complex-enc" class="headerlink" title="complex_enc"></a>complex_enc</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GET_KEY</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">2</span></span><br><span class="line">    key=[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        r=random.randint(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        x=<span class="built_in">sum</span>+random.randint(<span class="number">0</span>,n)*r</span><br><span class="line">        key.append(x)</span><br><span class="line">        <span class="built_in">sum</span>+=x</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">m,k</span>):</span><br><span class="line">    cipher_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">        <span class="keyword">if</span> m[i] == <span class="number">1</span>:</span><br><span class="line">            cipher_list.append(m[i] * k[i])</span><br><span class="line">    cipher = <span class="built_in">sum</span>(cipher_list)</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">m = [<span class="built_in">int</span>(bit) <span class="keyword">for</span> byte <span class="keyword">in</span> flag <span class="keyword">for</span> bit <span class="keyword">in</span> <span class="built_in">format</span>(byte, <span class="string">&#x27;08b&#x27;</span>)]</span><br><span class="line">key=GET_KEY(<span class="built_in">len</span>(m))</span><br><span class="line">c=enc(m,key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">str</span>(c))</span><br><span class="line">    f.write(<span class="built_in">str</span>(key))</span><br></pre></td></tr></table></figure><p>很容易可以看出key是一个超递增序列，将flag按字节转成了二进制并将每bit填入列表m中，所以能利用超递增序列的性质，从尾部逐个比较大小判断为0还是1，可参考moectf2023的minipack</p><p>不过要注意一下题目，因为key开始已经不是空列表所以生成的超递增序列长度实际是n+1，而加密m会用到的仅有n个，所以key的最后一个是用不到的可以直接删去，并且考虑key列表中的第一个数为1，可能后面会有相等的情况，如果是这样来：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">    <span class="keyword">if</span>(c &gt; key[<span class="built_in">len</span>(key)-<span class="number">1</span>-i]):</span><br><span class="line">        m.append(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        c -= key[<span class="built_in">len</span>(key)-<span class="number">1</span>-i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        m.append(<span class="string">&quot;0&quot;</span>)</span><br></pre></td></tr></table></figure><p>会发现最后输出的flag头部不对（变成b’\x84ASCTF{you_kn0w_b@ckpack_Crypt0?}’了，虽然能看出来原形）</p><p>加上一行print(c)就能发现这是因为减到最后c变成了2,1和key的开头一样，相等的情况被算入else记作0了，改成这样或者调一下位置就行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line">c=<span class="number">287687761937146187597379915545639385740275457170939564210821293233370716878150576</span></span><br><span class="line">key=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">87</span>, <span class="number">99</span>, <span class="number">190</span>, <span class="number">380</span>, <span class="number">760</span>, <span class="number">1702</span>, <span class="number">3350</span>, <span class="number">6712</span>, <span class="number">13302</span>, <span class="number">26669</span>, <span class="number">53257</span>, <span class="number">106512</span>, <span class="number">213212</span>, <span class="number">426262</span>, <span class="number">852583</span>, <span class="number">1705083</span>, <span class="number">3410164</span>, <span class="number">6820581</span>, <span class="number">13640909</span>, <span class="number">27281818</span>, <span class="number">54563749</span>, <span class="number">109127508</span>, <span class="number">218254958</span>, <span class="number">436509851</span>, <span class="number">873019897</span>, <span class="number">1746039768</span>, <span class="number">3492079367</span>, <span class="number">6984158992</span>, <span class="number">13968317822</span>, <span class="number">27936635563</span>, <span class="number">55873271257</span>, <span class="number">111746542368</span>, <span class="number">223493084736</span>, <span class="number">446986169472</span>, <span class="number">893972338944</span>, <span class="number">1787944677888</span>, <span class="number">3575889355776</span>, <span class="number">7151778711750</span>, <span class="number">14303557423366</span>, <span class="number">28607114846668</span>, <span class="number">57214229693336</span>, <span class="number">114428459386792</span>, <span class="number">228856918773559</span>, <span class="number">457713837547023</span>, <span class="number">915427675094046</span>, <span class="number">1830855350188252</span>, <span class="number">3661710700376344</span>, <span class="number">7323421400752912</span>, <span class="number">14646842801505675</span>, <span class="number">29293685603011275</span>, <span class="number">58587371206022773</span>, <span class="number">117174742412045483</span>, <span class="number">234349484824090806</span>, <span class="number">468698969648181659</span>, <span class="number">937397939296363271</span>, <span class="number">1874795878592726601</span>, <span class="number">3749591757185453143</span>, <span class="number">7499183514370906547</span>, <span class="number">14998367028741812852</span>, <span class="number">29996734057483625898</span>, <span class="number">59993468114967251756</span>, <span class="number">119986936229934503501</span>, <span class="number">239973872459869007099</span>, <span class="number">479947744919738013939</span>, <span class="number">959895489839476027878</span>, <span class="number">1919790979678952055983</span>, <span class="number">3839581959357904111739</span>, <span class="number">7679163918715808223719</span>, <span class="number">15358327837431616447319</span>, <span class="number">30716655674863232894717</span>, <span class="number">61433311349726465789458</span>, <span class="number">122866622699452931578804</span>, <span class="number">245733245398905863157495</span>, <span class="number">491466490797811726314990</span>, <span class="number">982932981595623452629980</span>, <span class="number">1965865963191246905260222</span>, <span class="number">3931731926382493810520182</span>, <span class="number">7863463852764987621040623</span>, <span class="number">15726927705529975242080987</span>, <span class="number">31453855411059950484161974</span>, <span class="number">62907710822119900968323970</span>, <span class="number">125815421644239801936647918</span>, <span class="number">251630843288479603873295836</span>, <span class="number">503261686576959207746591710</span>, <span class="number">1006523373153918415493183613</span>, <span class="number">2013046746307836830986367190</span>, <span class="number">4026093492615673661972734253</span>, <span class="number">8052186985231347323945468456</span>, <span class="number">16104373970462694647890936894</span>, <span class="number">32208747940925389295781874025</span>, <span class="number">64417495881850778591563748059</span>, <span class="number">128834991763701557183127495888</span>, <span class="number">257669983527403114366254991760</span>, <span class="number">515339967054806228732509983520</span>, <span class="number">1030679934109612457465019967093</span>, <span class="number">2061359868219224914930039934133</span>, <span class="number">4122719736438449829860079868450</span>, <span class="number">8245439472876899659720159736935</span>, <span class="number">16490878945753799319440319473651</span>, <span class="number">32981757891507598638880638947330</span>, <span class="number">65963515783015197277761277894728</span>, <span class="number">131927031566030394555522555789579</span>, <span class="number">263854063132060789111045111579109</span>, <span class="number">527708126264121578222090223158048</span>, <span class="number">1055416252528243156444180446316096</span>, <span class="number">2110832505056486312888360892632193</span>, <span class="number">4221665010112972625776721785264450</span>, <span class="number">8443330020225945251553443570528835</span>, <span class="number">16886660040451890503106887141057670</span>, <span class="number">33773320080903781006213774282115477</span>, <span class="number">67546640161807562012427548564230882</span>, <span class="number">135093280323615124024855097128461699</span>, <span class="number">270186560647230248049710194256923398</span>, <span class="number">540373121294460496099420388513846796</span>, <span class="number">1080746242588920992198840777027693592</span>, <span class="number">2161492485177841984397681554055387246</span>, <span class="number">4322984970355683968795363108110774528</span>, <span class="number">8645969940711367937590726216221549105</span>, <span class="number">17291939881422735875181452432443098117</span>, <span class="number">34583879762845471750362904864886196180</span>, <span class="number">69167759525690943500725809729772392360</span>, <span class="number">138335519051381887001451619459544784838</span>, <span class="number">276671038102763774002903238919089569616</span>, <span class="number">553342076205527548005806477838179139174</span>, <span class="number">1106684152411055096011612955676358278348</span>, <span class="number">2213368304822110192023225911352716556750</span>, <span class="number">4426736609644220384046451822705433113446</span>, <span class="number">8853473219288440768092903645410866226907</span>, <span class="number">17706946438576881536185807290821732453830</span>, <span class="number">35413892877153763072371614581643464907890</span>, <span class="number">70827785754307526144743229163286929815519</span>, <span class="number">141655571508615052289486458326573859631099</span>, <span class="number">283311143017230104578972916653147719262229</span>, <span class="number">566622286034460209157945833306295438524626</span>, <span class="number">1133244572068920418315891666612590877049074</span>, <span class="number">2266489144137840836631783333225181754098066</span>, <span class="number">4532978288275681673263566666450363508196132</span>, <span class="number">9065956576551363346527133332900727016392264</span>, <span class="number">18131913153102726693054266665801454032784553</span>, <span class="number">36263826306205453386108533331602908065569081</span>, <span class="number">72527652612410906772217066663205816131138180</span>, <span class="number">145055305224821813544434133326411632262276342</span>, <span class="number">290110610449643627088868266652823264524552684</span>, <span class="number">580221220899287254177736533305646529049105368</span>, <span class="number">1160442441798574508355473066611293058098210736</span>, <span class="number">2320884883597149016710946133222586116196421472</span>, <span class="number">4641769767194298033421892266445172232392842944</span>, <span class="number">9283539534388596066843784532890344464785686063</span>, <span class="number">18567079068777192133687569065780688929571371951</span>, <span class="number">37134158137554384267375138131561377859142743902</span>, <span class="number">74268316275108768534750276263122755718285487804</span>, <span class="number">148536632550217537069500552526245511436570975608</span>, <span class="number">297073265100435074139001105052491022873141951360</span>, <span class="number">594146530200870148278002210104982045746283902576</span>, <span class="number">1188293060401740296556004420209964091492567805360</span>, <span class="number">2376586120803480593112008840419928182985135610512</span>, <span class="number">4753172241606961186224017680839856365970271221024</span>, <span class="number">9506344483213922372448035361679712731940542442048</span>, <span class="number">19012688966427844744896070723359425463881084884096</span>, <span class="number">38025377932855689489792141446718850927762169768220</span>, <span class="number">76050755865711378979584282893437701855524339536412</span>, <span class="number">152101511731422757959168565786875403711048679072824</span>, <span class="number">304203023462845515918337131573750807422097358145648</span>, <span class="number">608406046925691031836674263147501614844194716291296</span>, <span class="number">1216812093851382063673348526295003229688389432582797</span>, <span class="number">2433624187702764127346697052590006459376778865165617</span>, <span class="number">4867248375405528254693394105180012918753557730331006</span>, <span class="number">9734496750811056509386788210360025837507115460662129</span>, <span class="number">19468993501622113018773576420720051675014230921324265</span>, <span class="number">38937987003244226037547152841440103350028461842648406</span>, <span class="number">77875974006488452075094305682880206700056923685296910</span>, <span class="number">155751948012976904150188611365760413400113847370593722</span>, <span class="number">311503896025953808300377222731520826800227694741187444</span>, <span class="number">623007792051907616600754445463041653600455389482374933</span>, <span class="number">1246015584103815233201508890926083307200910778964749821</span>, <span class="number">2492031168207630466403017781852166614401821557929499642</span>, <span class="number">4984062336415260932806035563704333228803643115858999284</span>, <span class="number">9968124672830521865612071127408666457607286231717998666</span>, <span class="number">19936249345661043731224142254817332915214572463435997301</span>, <span class="number">39872498691322087462448284509634665830429144926871994535</span>, <span class="number">79744997382644174924896569019269331660858289853743989190</span>, <span class="number">159489994765288349849793138038538663321716579707487978260</span>, <span class="number">318979989530576699699586276077077326643433159414975956596</span>, <span class="number">637959979061153399399172552154154653286866318829951913129</span>, <span class="number">1275919958122306798798345104308309306573732637659903826311</span>, <span class="number">2551839916244613597596690208616618613147465275319807652591</span>, <span class="number">5103679832489227195193380417233237226294930550639615305147</span>, <span class="number">10207359664978454390386760834466474452589861101279230610294</span>, <span class="number">20414719329956908780773521668932948905179722202558461220588</span>, <span class="number">40829438659913817561547043337865897810359444405116922441176</span>, <span class="number">81658877319827635123094086675731795620718888810233844882508</span>, <span class="number">163317754639655270246188173351463591241437777620467689764860</span>, <span class="number">326635509279310540492376346702927182482875555240935379529854</span>, <span class="number">653271018558621080984752693405854364965751110481870759059704</span>, <span class="number">1306542037117242161969505386811708729931502220963741518119363</span>, <span class="number">2613084074234484323939010773623417459863004441927483036238705</span>, <span class="number">5226168148468968647878021547246834919726008883854966072477346</span>, <span class="number">10452336296937937295756043094493669839452017767709932144954692</span>, <span class="number">20904672593875874591512086188987339678904035535419864289909384</span>, <span class="number">41809345187751749183024172377974679357808071070839728579818768</span>, <span class="number">83618690375503498366048344755949358715616142141679457159637536</span>, <span class="number">167237380751006996732096689511898717431232284283358914319275072</span>, <span class="number">334474761502013993464193379023797434862464568566717828638550144</span>, <span class="number">668949523004027986928386758047594869724929137133435657277100288</span>, <span class="number">1337899046008055973856773516095189739449858274266871314554200576</span>, <span class="number">2675798092016111947713547032190379478899716548533742629108401375</span>, <span class="number">5351596184032223895427094064380758957799433097067485258216802527</span>, <span class="number">10703192368064447790854188128761517915598866194134970516433605054</span>, <span class="number">21406384736128895581708376257523035831197732388269941032867210108</span>, <span class="number">42812769472257791163416752515046071662395464776539882065734420216</span>, <span class="number">85625538944515582326833505030092143324790929553079764131468840607</span>, <span class="number">171251077889031164653667010060184286649581859106159528262937681073</span>, <span class="number">342502155778062329307334020120368573299163718212319056525875362112</span>, <span class="number">685004311556124658614668040240737146598327436424638113051750724224</span>, <span class="number">1370008623112249317229336080481474293196654872849276226103501448448</span>, <span class="number">2740017246224498634458672160962948586393309745698552452207002896896</span>, <span class="number">5480034492448997268917344321925897172786619491397104904414005793914</span>, <span class="number">10960068984897994537834688643851794345573238982794209808828011587706</span>, <span class="number">21920137969795989075669377287703588691146477965588419617656023175412</span>, <span class="number">43840275939591978151338754575407177382292955931176839235312046350824</span>, <span class="number">87680551879183956302677509150814354764585911862353678470624092701691</span>, <span class="number">175361103758367912605355018301628709529171823724707356941248185403485</span>, <span class="number">350722207516735825210710036603257419058343647449414713882496370806824</span>, <span class="number">701444415033471650421420073206514838116687294898829427764992741613648</span>, <span class="number">1402888830066943300842840146413029676233374589797658855529985483227499</span>, <span class="number">2805777660133886601685680292826059352466749179595317711059970966454839</span>, <span class="number">5611555320267773203371360585652118704933498359190635422119941932909634</span>, <span class="number">11223110640535546406742721171304237409866996718381270844239883865819325</span>, <span class="number">22446221281071092813485442342608474819733993436762541688479767731638735</span>, <span class="number">44892442562142185626970884685216949639467986873525083376959535463277328</span>, <span class="number">89784885124284371253941769370433899278935973747050166753919070926554729</span>, <span class="number">179569770248568742507883538740867798557871947494100333507838141853109648</span>, <span class="number">359139540497137485015767077481735597115743894988200667015676283706219166</span>, <span class="number">718279080994274970031534154963471194231487789976401334031352567412438331</span>, <span class="number">1436558161988549940063068309926942388462975579952802668062705134824876530</span>, <span class="number">2873116323977099880126136619853884776925951159905605336125410269649753060</span>, <span class="number">5746232647954199760252273239707769553851902319811210672250820539299506381</span>, <span class="number">11492465295908399520504546479415539107703804639622421344501641078599012695</span>, <span class="number">22984930591816799041009092958831078215407609279244842689003282157198025444</span>, <span class="number">45969861183633598082018185917662156430815218558489685378006564314396050678</span>, <span class="number">91939722367267196164036371835324312861630437116979370756013128628792101318</span>, <span class="number">183879444734534392328072743670648625723260874233958741512026257257584202636</span>, <span class="number">367758889469068784656145487341297251446521748467917483024052514515168405272</span>, <span class="number">735517778938137569312290974682594502893043496935834966048105029030336810544</span>, <span class="number">1471035557876275138624581949365189005786086993871669932096210058060673621088</span>, <span class="number">2942071115752550277249163898730378011572173987743339864192420116121347242216</span>, <span class="number">5884142231505100554498327797460756023144347975486679728384840232242694484649</span>, <span class="number">11768284463010201108996655594921512046288695950973359456769680464485388969041</span>, <span class="number">23536568926020402217993311189843024092577391901946718913539360928970777938082</span>, <span class="number">47073137852040804435986622379686048185154783803893437827078721857941555876305</span>, <span class="number">94146275704081608871973244759372096370309567607786875654157443715883111752579</span>, <span class="number">188292551408163217743946489518744192740619135215573751308314887431766223505070</span>, <span class="number">376585102816326435487892979037488385481238270431147502616629774863532447010118</span>, <span class="number">753170205632652870975785958074976770962476540862295005233259549727064894020344</span>, <span class="number">1506340411265305741951571916149953541924953081724590010466519099454129788040580</span>, <span class="number">3012680822530611483903143832299907083849906163449180020933038198908259576081160</span>, <span class="number">6025361645061222967806287664599814167699812326898360041866076397816519152162452</span>, <span class="number">12050723290122445935612575329199628335399624653796720083732152795633038304324883</span>, <span class="number">24101446580244891871225150658399256670799249307593440167464305591266076608649853</span>, <span class="number">48202893160489783742450301316798513341598498615186880334928611182532153217299508</span>, <span class="number">96405786320979567484900602633597026683196997230373760669857222365064306434599262</span>, <span class="number">192811572641959134969801205267194053366393994460747521339714444730128612869198530</span>]</span><br><span class="line"></span><br><span class="line">m=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">    <span class="keyword">if</span>(c &gt; key[<span class="built_in">len</span>(key)-<span class="number">1</span>-i] <span class="keyword">or</span> c == key[<span class="built_in">len</span>(key)-<span class="number">1</span>-i] ):</span><br><span class="line">        m.append(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        c -= key[<span class="built_in">len</span>(key)-<span class="number">1</span>-i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        m.append(<span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(m)[::-<span class="number">1</span>],<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#b&#x27;DASCTF&#123;you_kn0w_b@ckpack_Crypt0?&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="1z-RSA"><a href="#1z-RSA" class="headerlink" title="1z_RSA"></a>1z_RSA</h4><p>题目描述：</p><p>我们来到了提瓦特与现实世界的边界，我们怎么卡进去呢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">nbit =<span class="number">130</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">l = getPrime(<span class="number">505</span>)</span><br><span class="line">m = bytes_to_long(flag + os.urandom(<span class="number">64</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag) == <span class="number">29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p, q = getPrime(nbit), getPrime(nbit)</span><br><span class="line">    PQ = <span class="built_in">int</span>(<span class="built_in">str</span>(p&lt;&lt;<span class="number">120</span>)+<span class="built_in">str</span>(q))</span><br><span class="line">    QP = <span class="built_in">int</span>(<span class="built_in">str</span>(q&lt;&lt;<span class="number">120</span>)+<span class="built_in">str</span>(p))</span><br><span class="line">    <span class="keyword">if</span> isPrime(PQ) <span class="keyword">and</span> isPrime(QP):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">n = PQ * QP</span><br><span class="line">PP = nextprime((PQ &gt;&gt; <span class="number">190</span>) * (QP &amp; (<span class="number">2</span> ** <span class="number">190</span> - <span class="number">1</span>)))</span><br><span class="line">QQ = nextprime((QP &gt;&gt; <span class="number">190</span>) * (PQ &amp; (<span class="number">2</span> ** <span class="number">190</span> - <span class="number">1</span>)))</span><br><span class="line">N = PP * QQ</span><br><span class="line">M = <span class="built_in">pow</span>(m,<span class="number">1</span>,l)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,N)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n =&#x27;</span>, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;M =&#x27;</span>, M)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;l =&#x27;</span>, l)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c =&#x27;</span>, c)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 18339446336492672809908730785358232636383625709800392830207979464962269419140428722248172110017576390002616004691759163126532392634394976712779777822451878822759056304050545622761060245812934467784888422790178920804822224673755691</span></span><br><span class="line"><span class="string">M = 36208281423355218604990190624029584747447986456188203264389519699277658026754156377638444926063784368328407938562964768329134840563331354924365667733322</span></span><br><span class="line"><span class="string">l = 56911058350450672322326236658556745353275014753768458552003425206272938093282425278193278997347671093622024933189270932102361261551908054703317369295189</span></span><br><span class="line"><span class="string">c = 720286366572443009268610917990845759123049408295363966717060100862857351750759651979922104897091176824666482923148635058966589592286465060161271579501861264957611980854954664798904862706450723639237791023808177615189976108231923</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>重点是这两句：    PQ = int(str(p&lt;&lt;120)+str(q))    QP = int(str(q&lt;&lt;120)+str(p))</p><p>所以可以写作： </p><script type="math/tex; mode=display">PQ=p*2^{120}*10^{x}+q\\ QP=q*2^{120}*10^{y}+p</script><p>通过测试可以知道p,q十进制的位数长度为39或40，也就是x和y等于39或40</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = getPrime(<span class="number">130</span>)</span><br><span class="line">    q = getPrime(<span class="number">130</span>)</span><br><span class="line">    temp = p*q</span><br><span class="line">    PQ = <span class="built_in">int</span>(<span class="built_in">str</span>(p&lt;&lt;<span class="number">120</span>)+<span class="built_in">str</span>(q))</span><br><span class="line">    QP = <span class="built_in">int</span>(<span class="built_in">str</span>(q&lt;&lt;<span class="number">120</span>)+<span class="built_in">str</span>(p))</span><br><span class="line">    n = PQ * QP</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(n)),end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(PQ)),end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(QP)),end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(p)),end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(q)),end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(temp)))</span><br></pre></td></tr></table></figure><p>此题中n的十进制长度为230，所以可以看出x,y实际应该为x=39,y=40</p><script type="math/tex; mode=display">n=PQ * QP=(p*2^{120}*10^{x}+q)*(q*2^{120}*10^{y}+p)\\ =(p*2^{120}*10^{39}+q)*(q*2^{120}*10^{40}+p)\\ =p*q*(2^{240}*10^{79}+1)+(10*p^{2}+q^{2})*2^{120}*10^{39}</script><p>因为我们已知n想求p*q，所以需要尽量将其他的去掉，观察 </p><script type="math/tex; mode=display">(2^{240}*10^{79}+1)</script><p>和</p><script type="math/tex; mode=display">(10*p^{2}+q^{2})*2^{120}*10^{39}</script><p>的大小又可以发现前者小于后者但是差距较小（以下为测试：倍数大致在400到1500之间）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p=getPrime(<span class="number">130</span>)</span><br><span class="line">    q=getPrime(<span class="number">130</span>)</span><br><span class="line">    a=(<span class="number">2</span>**<span class="number">240</span>*<span class="number">10</span>**<span class="number">79</span>+<span class="number">1</span>)</span><br><span class="line">    b=(<span class="number">10</span>*p**<span class="number">2</span>+q**<span class="number">2</span>)*<span class="number">2</span>**<span class="number">120</span>*<span class="number">10</span>**<span class="number">39</span></span><br><span class="line">    x=b//a</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>所以 </p><script type="math/tex; mode=display">pq=n//(2^{240}*10^{79}+1)-x</script><p>（取值范围或许就是题目描述里面的卡界？其实卡的并不严，因为前面说了前者小于后者又算了倍数关系，较容易能获得取值范围）</p><p>本来打算factor分解一下的结果发现分解不了，那么就解方程吧</p><p>已知 10<em>p**{2}</em>q<em>*{2}和p</em>q求解p,q解出后就能得到PQ,QP了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">n = <span class="number">18339446336492672809908730785358232636383625709800392830207979464962269419140428722248172110017576390002616004691759163126532392634394976712779777822451878822759056304050545622761060245812934467784888422790178920804822224673755691</span></span><br><span class="line">pq=n//(<span class="number">2</span>**<span class="number">240</span>*<span class="number">10</span>**<span class="number">79</span>+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pq -<span class="number">1500</span>,pq ):</span><br><span class="line">    <span class="keyword">if</span>(n-i*(<span class="number">2</span>**<span class="number">240</span>*<span class="number">10</span>**<span class="number">79</span>+<span class="number">1</span>))%(<span class="number">2</span>**<span class="number">120</span>*<span class="number">10</span> ** <span class="number">39</span>)== <span class="number">0</span>:</span><br><span class="line">        leak=(n-i*(<span class="number">2</span>**<span class="number">240</span>*<span class="number">10</span>**<span class="number">79</span>+<span class="number">1</span>))//(<span class="number">2</span> ** <span class="number">120</span>*<span class="number">10</span> ** <span class="number">39</span>)</span><br><span class="line">        p,q= symbols(<span class="string">&#x27;p q&#x27;</span>)</span><br><span class="line">        res=solve([p**<span class="number">2</span>+<span class="number">10</span>*q**<span class="number">2</span>-leak, p*q- i],[p,q])</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        <span class="keyword">for</span> pp,qq <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">if</span> pp &gt;<span class="number">0</span> <span class="keyword">and</span> qq &gt;<span class="number">0</span>:</span><br><span class="line">                PQ=<span class="built_in">int</span>(<span class="built_in">str</span>(<span class="built_in">int</span>(pp)&lt;&lt;<span class="number">120</span>)+ <span class="built_in">str</span>(<span class="built_in">int</span>(qq)))</span><br><span class="line">                QP =<span class="built_in">int</span>(<span class="built_in">str</span>(<span class="built_in">int</span>(qq)&lt;&lt;<span class="number">120</span>)+ <span class="built_in">str</span>(<span class="built_in">int</span>(pp)))</span><br><span class="line">                <span class="built_in">print</span>(PQ)</span><br><span class="line">                <span class="built_in">print</span>(QP)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>然后PP,QQ也就知道了，随即得知N</p><p>M=m+kl</p><p>c=m^{e}%N</p><p>c=(M+kl)%N</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">18339446336492672809908730785358232636383625709800392830207979464962269419140428722248172110017576390002616004691759163126532392634394976712779777822451878822759056304050545622761060245812934467784888422790178920804822224673755691</span></span><br><span class="line">M = <span class="number">36208281423355218604990190624029584747447986456188203264389519699277658026754156377638444926063784368328407938562964768329134840563331354924365667733322</span></span><br><span class="line">l = <span class="number">56911058350450672322326236658556745353275014753768458552003425206272938093282425278193278997347671093622024933189270932102361261551908054703317369295189</span></span><br><span class="line">c = <span class="number">720286366572443009268610917990845759123049408295363966717060100862857351750759651979922104897091176824666482923148635058966589592286465060161271579501861264957611980854954664798904862706450723639237791023808177615189976108231923</span></span><br><span class="line">N = <span class="number">763933528218428362740063144747893290714655295576768532896029874141179804730143020017430379534079773751531037961074867132893544981605022026151484151321515584652838724809597675412676810669583078026377048734720511960708515190930979</span></span><br><span class="line"></span><br><span class="line">PR.&lt;k&gt; = PolynomialRing(Zmod(N))</span><br><span class="line">f = c - (M+k*l)^<span class="number">3</span></span><br><span class="line">f = f.monic()</span><br><span class="line">roots = f.small_roots(X=<span class="number">2</span>^<span class="number">239</span>,epsilon = <span class="number">0.02</span>)</span><br><span class="line">k = roots[<span class="number">0</span>]</span><br><span class="line">m = M+k*l</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment">#b&#x27;DASCTF&#123;Ar3_Y0u_Su93_Abt139??&#125;\xb6C\xda\x90\xa1\xfb\x14\x1as\xc4Sz\x92\xaeg:Z\x16ESH\xd11\x91\xee\x8aF\x9f\x17\xd6\xbb\xf9\x06i\x9e\xc4l\xfcC\x0c\x00\x9e\xdb\x13\x02+yN\xf0\x85\xad\xfe\xfd&amp;\x97T\xbfd\xac\xf8\xff\xaeq\x06&#x27;</span></span><br></pre></td></tr></table></figure><p>得到flag</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剪枝</title>
      <link href="/2024/07/18/%E5%89%AA%E6%9E%9D/"/>
      <url>/2024/07/18/%E5%89%AA%E6%9E%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>最近ctfshow西瓜杯做到一题</p><h4 id="factor"><a href="#factor" class="headerlink" title="factor"></a>factor</h4><p>附件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> enc <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">hint = os.urandom(<span class="number">36</span>)</span><br><span class="line">tmp = bytes_to_long(hint)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">d = getPrime(<span class="number">400</span>)</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">e = gmpy2.invert(d,phi)</span><br><span class="line">n = p*q</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line">leak1 = p^tmp</span><br><span class="line">leak2 = q^tmp</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n = <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;e = <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c = <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;leak1 = <span class="subst">&#123;leak1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;leak2 = <span class="subst">&#123;leak2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 145462084881728813723574366340552281785604069047381248513937024180816353963950721541845665931261230969450819680771925091152670386983240444354412170994932196142227905635227116456476835756039585419001941477905953429642459464112871080459522266599791339252614674500304621383776590313803782107531212756620796159703</span></span><br><span class="line"><span class="string">e = 10463348796391625387419351013660920157452350067191419373870543363741187885528042168135531161031114295856009050029737547684735896660393845515549071092389128688718675573348847489182651631515852744312955427364280891600765444324519789452014742590962030936762237037273839906251320666705879080373711858513235704113</span></span><br><span class="line"><span class="string">c = 60700608730139668338977678601901211800978306010063875269252006068222163102100346920465298044880066999492746508990629867396189713753873657197546664480233269806308415874191048149900822050054539774370134460339681949131037133783273410066318511508768512778132786573893529705068680583697574367357381635982316477364</span></span><br><span class="line"><span class="string">leak1 = 13342820281239625174817085182586822673810894195223942279061039858850534510679297962596800315875604798047264337469828123370586584840078728059729121435462780</span></span><br><span class="line"><span class="string">leak2 = 10901899434728393473569359914062349292412269512201554924835672710780580634465799069211035290729536290605761024818770843901501694556825737462457471235151530</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>比较简单</p><p>可以看出关键是异或，且已知leak1和leak2，将二者异或得到的就是p和q异或的值，所以想到剪枝</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line">n = <span class="number">145462084881728813723574366340552281785604069047381248513937024180816353963950721541845665931261230969450819680771925091152670386983240444354412170994932196142227905635227116456476835756039585419001941477905953429642459464112871080459522266599791339252614674500304621383776590313803782107531212756620796159703</span></span><br><span class="line">e = <span class="number">10463348796391625387419351013660920157452350067191419373870543363741187885528042168135531161031114295856009050029737547684735896660393845515549071092389128688718675573348847489182651631515852744312955427364280891600765444324519789452014742590962030936762237037273839906251320666705879080373711858513235704113</span></span><br><span class="line">c = <span class="number">60700608730139668338977678601901211800978306010063875269252006068222163102100346920465298044880066999492746508990629867396189713753873657197546664480233269806308415874191048149900822050054539774370134460339681949131037133783273410066318511508768512778132786573893529705068680583697574367357381635982316477364</span></span><br><span class="line">leak1 = <span class="number">13342820281239625174817085182586822673810894195223942279061039858850534510679297962596800315875604798047264337469828123370586584840078728059729121435462780</span></span><br><span class="line">leak2 = <span class="number">10901899434728393473569359914062349292412269512201554924835672710780580634465799069211035290729536290605761024818770843901501694556825737462457471235151530</span></span><br><span class="line">xor=leak1^leak2</span><br><span class="line">pbits=<span class="number">512</span></span><br><span class="line">xor = <span class="built_in">str</span>(<span class="built_in">bin</span>(xor)[<span class="number">2</span>:]).zfill(pbits)</span><br><span class="line"></span><br><span class="line">ph = <span class="string">&#x27;&#x27;</span></span><br><span class="line">qh = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">ph,qh</span>):</span><br><span class="line">    l0 = <span class="built_in">len</span>(ph)</span><br><span class="line">    l1 = <span class="built_in">len</span>(qh)</span><br><span class="line">    tmp0 = ph + <span class="string">&#x27;0&#x27;</span> * (pbits-l0)</span><br><span class="line">    tmp1 = ph + <span class="string">&#x27;1&#x27;</span> * (pbits-l0)</span><br><span class="line">    tmq0 = qh + <span class="string">&#x27;0&#x27;</span> * (pbits-l1)</span><br><span class="line">    tmq1 = qh + <span class="string">&#x27;1&#x27;</span> * (pbits-l1)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(tmp0,<span class="number">2</span>) * <span class="built_in">int</span>(tmq0,<span class="number">2</span>) &gt; n:<span class="comment">#剪枝条件1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(tmp1,<span class="number">2</span>) * <span class="built_in">int</span>(tmq1,<span class="number">2</span>) &lt; n:<span class="comment">#剪枝条件2</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> l0 == pbits:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(ph,<span class="number">2</span>) * <span class="built_in">int</span>(qh,<span class="number">2</span>) == n:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;p = <span class="subst">&#123;<span class="built_in">int</span>(ph,<span class="number">2</span>)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;q = <span class="subst">&#123;<span class="built_in">int</span>(qh,<span class="number">2</span>)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> xor[l1] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            find(ph+<span class="string">&#x27;0&#x27;</span>,qh+<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            find(ph+<span class="string">&#x27;1&#x27;</span>,qh+<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            find(ph+<span class="string">&#x27;1&#x27;</span>,qh+<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            find(ph+<span class="string">&#x27;0&#x27;</span>,qh+<span class="string">&#x27;0&#x27;</span>)    </span><br><span class="line"></span><br><span class="line">find(ph,qh)</span><br><span class="line"></span><br><span class="line">p=<span class="number">13342820281239625174817085182586822673810894195223942279061039858850820238924757629478502588722905946742147654397240559596444430114180174785691409037959681</span></span><br><span class="line">q=<span class="number">10901899434728393473569359914062349292412269512201554924835672710780357314223209262466102457697460432424101968655028724203256351586952677194451591494555863</span></span><br><span class="line"></span><br><span class="line">d=gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#b&#x27;cftshow&#123;do_you_know_what_is_xor_and_prune!!!&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>比较容易想到这个思路</p><p>写到这题了那就再写一下剪枝吧^_^</p><p>简单的剪枝比较容易看出来，像上面那题套个脚本就出了</p><h4 id="p-q"><a href="#p-q" class="headerlink" title="p^q"></a>p^q</h4><p>就像上面那题，给出p*q和p^q，对于每一位p^q的结果来说，该位的组合情况有 4 种1^0,0^1,1^1,0^0</p><p>搜索方式是从低位开始搜索,根据</p><script type="math/tex; mode=display">p_{low}*q_{low}=n_{low}</script><p>条件限定，并且需要满足</p><p>将p和q剩下位全部填充为1，需要满足 p*q &gt; n</p><p>将p和q剩下位全部填充为0，需要满足 p*q &lt; n</p><p>脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pbits=</span><br><span class="line">xor = <span class="built_in">str</span>(<span class="built_in">bin</span>(xor)[<span class="number">2</span>:]).zfill(pbits)</span><br><span class="line">ph = <span class="string">&#x27;&#x27;</span></span><br><span class="line">qh = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">ph,qh</span>):</span><br><span class="line">    l0 = <span class="built_in">len</span>(ph)</span><br><span class="line">    l1 = <span class="built_in">len</span>(qh)</span><br><span class="line">    tmp0 = ph + <span class="string">&#x27;0&#x27;</span> * (pbits-l0)</span><br><span class="line">    tmp1 = ph + <span class="string">&#x27;1&#x27;</span> * (pbits-l0)</span><br><span class="line">    tmq0 = qh + <span class="string">&#x27;0&#x27;</span> * (pbits-l1)</span><br><span class="line">    tmq1 = qh + <span class="string">&#x27;1&#x27;</span> * (pbits-l1)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(tmp0,<span class="number">2</span>) * <span class="built_in">int</span>(tmq0,<span class="number">2</span>) &gt; n:<span class="comment">#剪枝条件1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(tmp1,<span class="number">2</span>) * <span class="built_in">int</span>(tmq1,<span class="number">2</span>) &lt; n:<span class="comment">#剪枝条件2</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> l0 == pbits:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(ph,<span class="number">2</span>) * <span class="built_in">int</span>(qh,<span class="number">2</span>) == n:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;p = <span class="subst">&#123;<span class="built_in">int</span>(ph,<span class="number">2</span>)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;q = <span class="subst">&#123;<span class="built_in">int</span>(qh,<span class="number">2</span>)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> xor[l1] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            find(ph+<span class="string">&#x27;0&#x27;</span>,qh+<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            find(ph+<span class="string">&#x27;1&#x27;</span>,qh+<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            find(ph+<span class="string">&#x27;1&#x27;</span>,qh+<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            find(ph+<span class="string">&#x27;0&#x27;</span>,qh+<span class="string">&#x27;0&#x27;</span>)    </span><br><span class="line"></span><br><span class="line">find(ph,qh)</span><br></pre></td></tr></table></figure><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>帕鲁杯 江枫渔火对愁眠</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">flag = <span class="string">b&#x27;paluctf&#123;******************&#125;&#x27;</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line">leak1 = p &amp; q</span><br><span class="line">leak2 = p | q</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(leak1)</span><br><span class="line"><span class="built_in">print</span>(leak2)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 116117067844956812459549519789301338092862193317140117457423221066709482979351921356314593636327834899992321545232613626111009441254302384449742843180876494341637589103640217194070886174972452908589438599697165869525189266606983974250478298162924187424655566019487631330678770727392051485223152309309085945253</span></span><br><span class="line"><span class="comment"># 8605081049583982438298440507920076587069196185463800658188799677857096281403951362058424551032224336538547998962815392172493849395335237855201439663804417</span></span><br><span class="line"><span class="comment"># 13407373154151815187508645556332614349998109820361387104317659096666170318961881115942116046384020162789239054091769561534320831478500568385569270082820389</span></span><br><span class="line"><span class="comment"># 77391898018025866504652357285886871686506090492775075964856060726697268476460193878086905273672532025686191143120456958000415501059102146339274402932542049355257662649758904431953601814453558068056853653214769669690930883469679763807974430229116956128100328073573783801082618261383412539474900566590518020658</span></span><br></pre></td></tr></table></figure><p>看起来非常简单，结果卡住了，我印象里|和^都是按位异或，但试了一下才发现实际上是</p><p>| 按位或：对应位有一个为1则为1。   </p><p>^按位异或：对应位不同则为1，相同则为0。（我是笨蛋，这都会记错</p><p>所以leak1^leak2=p^q，常规剪枝</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">n=<span class="number">116117067844956812459549519789301338092862193317140117457423221066709482979351921356314593636327834899992321545232613626111009441254302384449742843180876494341637589103640217194070886174972452908589438599697165869525189266606983974250478298162924187424655566019487631330678770727392051485223152309309085945253</span></span><br><span class="line">leak1=<span class="number">8605081049583982438298440507920076587069196185463800658188799677857096281403951362058424551032224336538547998962815392172493849395335237855201439663804417</span></span><br><span class="line">leak2=<span class="number">13407373154151815187508645556332614349998109820361387104317659096666170318961881115942116046384020162789239054091769561534320831478500568385569270082820389</span></span><br><span class="line">xor=leak1^leak2</span><br><span class="line">pbits=<span class="number">512</span></span><br><span class="line">xor = <span class="built_in">str</span>(<span class="built_in">bin</span>(xor)[<span class="number">2</span>:]).zfill(pbits)</span><br><span class="line">ph = <span class="string">&#x27;&#x27;</span></span><br><span class="line">qh = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">ph,qh</span>):</span><br><span class="line">    l0 = <span class="built_in">len</span>(ph)</span><br><span class="line">    l1 = <span class="built_in">len</span>(qh)</span><br><span class="line">    tmp0 = ph + <span class="string">&#x27;0&#x27;</span> * (pbits-l0)</span><br><span class="line">    tmp1 = ph + <span class="string">&#x27;1&#x27;</span> * (pbits-l0)</span><br><span class="line">    tmq0 = qh + <span class="string">&#x27;0&#x27;</span> * (pbits-l1)</span><br><span class="line">    tmq1 = qh + <span class="string">&#x27;1&#x27;</span> * (pbits-l1)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(tmp0,<span class="number">2</span>) * <span class="built_in">int</span>(tmq0,<span class="number">2</span>) &gt; n:<span class="comment">#剪枝条件1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(tmp1,<span class="number">2</span>) * <span class="built_in">int</span>(tmq1,<span class="number">2</span>) &lt; n:<span class="comment">#剪枝条件2</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> l0 == pbits:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(ph,<span class="number">2</span>) * <span class="built_in">int</span>(qh,<span class="number">2</span>) == n:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;p = <span class="subst">&#123;<span class="built_in">int</span>(ph,<span class="number">2</span>)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;q = <span class="subst">&#123;<span class="built_in">int</span>(qh,<span class="number">2</span>)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> xor[l1] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            find(ph+<span class="string">&#x27;0&#x27;</span>,qh+<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            find(ph+<span class="string">&#x27;1&#x27;</span>,qh+<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            find(ph+<span class="string">&#x27;1&#x27;</span>,qh+<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            find(ph+<span class="string">&#x27;0&#x27;</span>,qh+<span class="string">&#x27;0&#x27;</span>)    </span><br><span class="line"></span><br><span class="line">find(ph,qh)</span><br><span class="line"></span><br><span class="line">p=<span class="number">8765698777357218895930455433534622474349736018036786722894513584283441223303812128653973162721831346202633677284766954990094900299096944074318482652846369</span></span><br><span class="line">q=<span class="number">13246755426378578729876630630718068462717569987788401039611945190239825377062020349346567434694413153125153375769817998716719780574738862166452227093778437</span></span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line">c=<span class="number">77391898018025866504652357285886871686506090492775075964856060726697268476460193878086905273672532025686191143120456958000415501059102146339274402932542049355257662649758904431953601814453558068056853653214769669690930883469679763807974430229116956128100328073573783801082618261383412539474900566590518020658</span></span><br><span class="line">d=gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line"><span class="comment">#b&#x27;paluctf&#123;&amp;&amp;&amp;|||&amp;&amp;&amp;|||&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;|||||||||&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="首尾剪枝-p-q-rev"><a href="#首尾剪枝-p-q-rev" class="headerlink" title="首尾剪枝(p^q_rev)"></a>首尾剪枝(p^q_rev)</h4><p>已知p与反方向二进制的q异或的值和p*q</p><p>从两端向中间搜索，每次搜索利用p^q_rev当前位数（与p^q_rev当前最高位有关的是当前p的最高位和q的最低位，p^q_rev当前最低位有关的是当前p的最低位和q的最高位）</p><p>如果当前搜索的最高位为”1”，则可能是：p该位为1，q对应低位为0；p该位为0，q对应低位为1。</p><p>如果当前搜索的最高位为”0”，则可能是：p该位为0，q对应低位为0；p该位为1，q对应低位为1。</p><p>搜索最低位也一样</p><p>从以下几个限定剪枝：</p><p>将p、q未搜索到的位全填0，乘积应该小于n;</p><p>将p、q未搜索到的位全填1，乘积应该大于n;</p><p>p、q低k位乘积再取低k位应该和n的低k位相同</p><p>脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">ph,qh,pl,ql</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(ph)</span><br><span class="line">    tmp0 = ph + (<span class="number">256</span>-<span class="number">2</span>*l)*<span class="string">&quot;0&quot;</span> + pl</span><br><span class="line">    tmp1 = ph + (<span class="number">256</span>-<span class="number">2</span>*l)*<span class="string">&quot;1&quot;</span> + pl</span><br><span class="line">    tmq0 = qh + (<span class="number">256</span>-<span class="number">2</span>*l)*<span class="string">&quot;0&quot;</span> + ql</span><br><span class="line">    tmq1 = qh + (<span class="number">256</span>-<span class="number">2</span>*l)*<span class="string">&quot;1&quot;</span> + ql</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(tmp0,<span class="number">2</span>)*<span class="built_in">int</span>(tmq0,<span class="number">2</span>) &gt; n):</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(tmp1,<span class="number">2</span>)*<span class="built_in">int</span>(tmq1,<span class="number">2</span>) &lt; n):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(pl,<span class="number">2</span>)*<span class="built_in">int</span>(ql,<span class="number">2</span>) % (<span class="number">2</span>**(l-<span class="number">1</span>)) != n % (<span class="number">2</span>**(l-<span class="number">1</span>))):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">128</span>):</span><br><span class="line">        pp0 = <span class="built_in">int</span>(tmp0,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(n % pp0 == <span class="number">0</span>):</span><br><span class="line">            pf = pp0</span><br><span class="line">            qf = n//pp0</span><br><span class="line">            phi = (pf-<span class="number">1</span>)*(qf-<span class="number">1</span>)</span><br><span class="line">            d = inverse(e,phi)</span><br><span class="line">            m1 = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(m1))</span><br><span class="line">            exit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span>(pxorq[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> pxorq[<span class="number">255</span>-l] == <span class="string">&quot;1&quot;</span>):</span><br><span class="line">            find(ph+<span class="string">&quot;1&quot;</span>,qh+<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>+pl,<span class="string">&quot;0&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;0&quot;</span>,qh+<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>+pl,<span class="string">&quot;1&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;1&quot;</span>,qh+<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>+pl,<span class="string">&quot;0&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;0&quot;</span>,qh+<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>+pl,<span class="string">&quot;1&quot;</span>+ql)</span><br><span class="line">        <span class="keyword">elif</span>(pxorq[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> pxorq[<span class="number">255</span>-l] == <span class="string">&quot;0&quot;</span>):</span><br><span class="line">            find(ph+<span class="string">&quot;1&quot;</span>,qh+<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>+pl,<span class="string">&quot;0&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;0&quot;</span>,qh+<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>+pl,<span class="string">&quot;1&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;1&quot;</span>,qh+<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>+pl,<span class="string">&quot;0&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;0&quot;</span>,qh+<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>+pl,<span class="string">&quot;1&quot;</span>+ql)</span><br><span class="line">        <span class="keyword">elif</span>(pxorq[l] == <span class="string">&quot;0&quot;</span> <span class="keyword">and</span> pxorq[<span class="number">255</span>-l] == <span class="string">&quot;1&quot;</span>):</span><br><span class="line">            find(ph+<span class="string">&quot;0&quot;</span>,qh+<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>+pl,<span class="string">&quot;0&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;0&quot;</span>,qh+<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>+pl,<span class="string">&quot;0&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;1&quot;</span>,qh+<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>+pl,<span class="string">&quot;1&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;1&quot;</span>,qh+<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>+pl,<span class="string">&quot;1&quot;</span>+ql)</span><br><span class="line">        <span class="keyword">elif</span>(pxorq[l] == <span class="string">&quot;0&quot;</span> <span class="keyword">and</span> pxorq[<span class="number">255</span>-l] == <span class="string">&quot;0&quot;</span>):</span><br><span class="line">            find(ph+<span class="string">&quot;0&quot;</span>,qh+<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>+pl,<span class="string">&quot;0&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;1&quot;</span>,qh+<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>+pl,<span class="string">&quot;1&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;0&quot;</span>,qh+<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>+pl,<span class="string">&quot;0&quot;</span>+ql)</span><br><span class="line">            find(ph+<span class="string">&quot;1&quot;</span>,qh+<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>+pl,<span class="string">&quot;1&quot;</span>+ql)</span><br></pre></td></tr></table></figure><h4 id="p-q-gt-gt-kbits"><a href="#p-q-gt-gt-kbits" class="headerlink" title="p^(q&gt;&gt;kbits)"></a>p^(q&gt;&gt;kbits)</h4><h5 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h5><p>已知n=p*q和p^(q&gt;&gt;kbits)</p><p>从高位向低位搜索，p的高kbits位已知（与给出的p^(q&gt;&gt;kbits)值的高kbits位相同），那搜索就从p^(q&gt;&gt;kbits)的kbits位后开始，即p的第kbits位，q的第1位。</p><p>若p^(q&gt;&gt;kbits)搜索的当前位值为1，则可能为：p为1，q为0 或者 p为0，q为1；反之若p^(q&gt;&gt;kbits)当前位为0，则p为1，q为1 或者 p为0，q为0。（p,q指的都是对应位的）</p><p>剪枝条件：</p><p>将p和q剩下位全部填充为1，需要满足 p*q &gt; n</p><p>将p和q剩下位全部填充为0，需要满足 p*q &lt; n</p><p>要注意把p的已知的高kbits位加上</p><p>结束条件是 </p><script type="math/tex; mode=display">n \mod\ p =0</script><p>脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = </span><br><span class="line">xor = </span><br><span class="line">kbits = </span><br><span class="line">pbits = </span><br><span class="line">xor = <span class="built_in">str</span>(<span class="built_in">bin</span>(xor)[<span class="number">2</span>:])</span><br><span class="line">ph = xor[:kbits]</span><br><span class="line">qh = <span class="string">&#x27;&#x27;</span></span><br><span class="line">xor = xor[kbits:]</span><br><span class="line">qh = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">ph,qh</span>):</span><br><span class="line">    l0 = <span class="built_in">len</span>(ph)</span><br><span class="line">    l1 = <span class="built_in">len</span>(qh)</span><br><span class="line">    tmp0 = ph + <span class="string">&#x27;0&#x27;</span> * (pbits-l0)</span><br><span class="line">    tmp1 = ph + <span class="string">&#x27;1&#x27;</span> * (pbits-l0)</span><br><span class="line">    tmq0 = qh + <span class="string">&#x27;0&#x27;</span> * (pbits-l1)</span><br><span class="line">    tmq1 = qh + <span class="string">&#x27;1&#x27;</span> * (pbits-l1)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(tmp0,<span class="number">2</span>) * <span class="built_in">int</span>(tmq0,<span class="number">2</span>) &gt; n:<span class="comment">#剪枝条件1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(tmp1,<span class="number">2</span>) * <span class="built_in">int</span>(tmq1,<span class="number">2</span>) &lt; n:<span class="comment">#剪枝条件2</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> l0 == pbits:<span class="comment">#结束条件</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="built_in">int</span>(ph,<span class="number">2</span>) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;p = <span class="subst">&#123;<span class="built_in">int</span>(ph,<span class="number">2</span>)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> xor[l1] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            find(ph+<span class="string">&#x27;0&#x27;</span>,qh+<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            find(ph + <span class="string">&#x27;1&#x27;</span>,qh+<span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            find(ph+<span class="string">&#x27;1&#x27;</span>,qh+<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            find(ph + <span class="string">&#x27;0&#x27;</span>,qh+<span class="string">&#x27;0&#x27;</span>)    </span><br><span class="line">find(ph,qh)</span><br></pre></td></tr></table></figure><h5 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h5><p>因为异或后的高 kbits 位就是 P 的高 kbits 位。用 N 除以 P 后得到的就是 Q 的高位，再次利用 Q 的高位和 gift，可以求出 P 的 kbits ～ 2*kbits 位，以此类推来恢复 P、Q。</p><p>例如下面这个：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">P = getPrime(<span class="number">512</span>)</span><br><span class="line">Q = getPrime(<span class="number">512</span>)</span><br><span class="line">N = P * Q</span><br><span class="line">gift = P ^ (Q &gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pbar = gift &gt;&gt;(<span class="number">512</span>-<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        qbar = (N&gt;&gt;(<span class="number">1024</span> - pbar.bit_length()*<span class="number">2</span>))//pbar</span><br><span class="line">        qbar = qbar&gt;&gt;<span class="number">6</span></span><br><span class="line">        gifts = gift^(qbar&lt;&lt;(<span class="number">512</span>-<span class="number">16</span>-qbar.bit_length()))</span><br><span class="line">        pbar = gifts &gt;&gt; (<span class="number">512</span>-<span class="number">16</span>-qbar.bit_length())</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">    <span class="keyword">if</span> N%((pbar&lt;&lt;<span class="number">6</span>)+i) == <span class="number">0</span>:</span><br><span class="line">        p = (pbar&lt;&lt;<span class="number">6</span>)+i</span><br><span class="line">        q = N//p</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] p =&quot;</span>,p)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] q =&quot;</span>,q)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>来源： <a href="https://sch01ar.github.io/2023/11/07/剪枝/#pqnbits"> 一些关于p^q问题剪枝算法 _ </a></p><p>我一开始不明白右移6位这个6是怎么来的，下面那个左移的位数和上面那个右移的联系是啥</p><p>后面貌似想明白了</p><p>直接说结论吧：上面那个6取别的值也是可以的，不能大于kbits，下面那个值则是最后的pbits-kbits-qbar.bit_length()</p><p>也就是说这个脚本也可以写成这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = </span><br><span class="line">xor = </span><br><span class="line">kbits = </span><br><span class="line">pbits = </span><br><span class="line">pbar = xor &gt;&gt;(pbits-kbits)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        qbar = (n&gt;&gt;(n.bit_length() - pbar.bit_length()*<span class="number">2</span>))//pbar</span><br><span class="line">        qbar = qbar&gt;&gt;kbits-<span class="number">1</span></span><br><span class="line">        xors = xor^(qbar&lt;&lt;(pbits-kbits-qbar.bit_length()))</span><br><span class="line">        pbar = xors &gt;&gt; (pbits-kbits-qbar.bit_length())</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n.bit_length()//kbits):</span><br><span class="line">    <span class="keyword">if</span> n%(pbar+i) == <span class="number">0</span>:</span><br><span class="line">        p =pbar+i</span><br><span class="line">        q = n//p</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] p =&quot;</span>,p)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] q =&quot;</span>,q)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>（更好套一点，原博客的别的题不能直接套）</p><h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><p>DASCTF 2023 &amp; 0X401七月暑期挑战赛 ezRSA</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> secret, flag</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="keyword">assert</span> flag == <span class="string">b&quot;dasctf&#123;&quot;</span> + secret + <span class="string">b&quot;&#125;&quot;</span></span><br><span class="line">e = <span class="number">11</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">P = getPrime(<span class="number">512</span>)</span><br><span class="line">Q = getPrime(<span class="number">512</span>)</span><br><span class="line">N = P * Q</span><br><span class="line">gift = P ^ (Q &gt;&gt; <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(N, gift, <span class="built_in">pow</span>(n, e, N))</span><br><span class="line"><span class="built_in">print</span>(encrypt(bytes_to_long(secret)),</span><br><span class="line">    encrypt(bytes_to_long(flag)))</span><br><span class="line"></span><br><span class="line">N = <span class="number">75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span></span><br><span class="line">gift = <span class="number">8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span></span><br><span class="line">c1 = <span class="number">14183763184495367653522884147951054630177015952745593358354098952173965560488104213517563098676028516541915855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span></span><br><span class="line">c2 = <span class="number">69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span></span><br><span class="line">c3 = <span class="number">46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span></span><br></pre></td></tr></table></figure><p>P,Q的获取可用剪枝获得，得到之后可得n</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">N = <span class="number">75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span></span><br><span class="line">xor = <span class="number">8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span></span><br><span class="line">c1 = <span class="number">14183763184495367653522884147951054630177015952745593358354098952173965560488104213517563098676028516541915855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span></span><br><span class="line">kbits = <span class="number">16</span></span><br><span class="line">pbits = <span class="number">512</span></span><br><span class="line">pbar = xor &gt;&gt;(pbits-kbits)</span><br><span class="line">e=<span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        qbar = (N&gt;&gt;(N.bit_length() - pbar.bit_length()*<span class="number">2</span>))//pbar</span><br><span class="line">        qbar = qbar&gt;&gt;kbits-<span class="number">1</span></span><br><span class="line">        xors = xor^(qbar&lt;&lt;(pbits-kbits-qbar.bit_length()))</span><br><span class="line">        pbar = xors &gt;&gt; (pbits-kbits-qbar.bit_length())</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N.bit_length()//kbits):</span><br><span class="line">    <span class="keyword">if</span> N%(pbar+i) == <span class="number">0</span>:</span><br><span class="line">        p =pbar+i</span><br><span class="line">        q = N//p</span><br><span class="line">        d=gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,<span class="built_in">pow</span>(c1,d,N))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#n= 8410363083727227985204019150296233995423906412694890252698371563789022268553444336554986979907257458547381598181369620318848637391220240378808211998052306324620364339595355706922325759625785590466818309839146408927226283350419069859849879835884942537531811470537915106995685907400782213608736735862576031042</span></span><br></pre></td></tr></table></figure><p>结果一看，发现求出的n结尾居然是2，并且长度只有1020位，所以可以想到是因为n&gt;N导致结果-N，所以真实的n应该再加上N,验算位数正好是1024位，然后是Franklin-Reiter攻击解flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">N = <span class="number">75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span></span><br><span class="line">n1= <span class="number">8410363083727227985204019150296233995423906412694890252698371563789022268553444336554986979907257458547381598181369620318848637391220240378808211998052306324620364339595355706922325759625785590466818309839146408927226283350419069859849879835884942537531811470537915106995685907400782213608736735862576031042</span></span><br><span class="line">n=n1+N</span><br><span class="line">c2 = <span class="number">69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span></span><br><span class="line">c3 = <span class="number">46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GCD</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a.monic()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> GCD(b,a % b)</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    f1 = x ^ <span class="number">11</span> - c2</span><br><span class="line">    f2 = (bytes_to_long(<span class="string">b&#x27;dasctf&#123;&#x27;</span> + <span class="string">b&#x27;\x00&#x27;</span> * i + <span class="string">b&#x27;&#125;&#x27;</span>) + <span class="number">256</span> * x) ^ <span class="number">11</span> - c3</span><br><span class="line">    <span class="keyword">if</span> GCD(f1,f2)[<span class="number">0</span>] != <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(n - GCD(f1,f2)[<span class="number">0</span>])))</span><br><span class="line"><span class="comment">#b&#x27;C0pper_Sm1th_Mak3s_T1ng5_Bet4er&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="nextprime剪枝"><a href="#nextprime剪枝" class="headerlink" title="nextprime剪枝"></a>nextprime剪枝</h4><p>类似于这题</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    p = getPrime(<span class="number">512</span>)</span><br><span class="line">    q = nextprime(<span class="built_in">int</span>(<span class="built_in">str</span>(p)[::-<span class="number">1</span>]))</span><br><span class="line">    a = p&amp;(<span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line">    b = q%(<span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">return</span> p, q, a, b</span><br><span class="line"></span><br><span class="line">p, q, a, b = gen()</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(flag, e, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a =&#x27;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b =&#x27;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n =&#x27;</span>, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c =&#x27;</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a = 393792</span></span><br><span class="line"><span class="string">b = 657587</span></span><br><span class="line"><span class="string">n = 369861662178631957928245949770898273807810914183024109983427665445735262653137205864716795669578458854257293391751966280054435051199001813062804877555180285022533020724584142987601931508644551710279816508694942797383860411279321090090880184911983657558416043011288974643282183209071299542379616927857228873411</span></span><br><span class="line"><span class="string">c = 71672159337725868237152385281240906653912972455699529924728534161923598107229667985188160316648005550663968313537597184857765083556920840254397949219027087098695062021613177519248117588571374167137534818793726427056016629301262986053118989821488864074425276527050110912787300008659230186841168308795745942580</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>与普通首尾剪枝的区别在于这边逆序是十进制而普通的是二进制，且这题取逆序之后还进行了一次nextprime</p><p>如果能爆破出p的低6位，也就有了q的高6位，因为给的b泄露了q的低6位，n的低6位一定等于p*q的低6位，所以可以爆破得到p的低6位从而得到q的高6位。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#find plow</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">    <span class="keyword">if</span>(i*b % (<span class="number">10</span>**<span class="number">6</span>) == n % (<span class="number">10</span>**<span class="number">6</span>)):</span><br><span class="line">        plow = <span class="built_in">str</span>(i)</span><br><span class="line"></span><br><span class="line">qhigh = plow[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>因为nextprime偏移很小一般不会超过2000，且q的低6位泄露，q是p十进制逆序的下一个值，所以q的低6位偏移不超过2000再倒序就是p的高6位，可以爆破得到。</p><p>爆破的依据是：</p><p>对可能的p高六位后面填充全0，与q高六位后面填充全0，乘积应小于n</p><p>对可能的p高六位后面填充全9，与q高六位后面填充全9，乘积应大于n</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#find phigh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>):</span><br><span class="line">    phigh = <span class="built_in">str</span>(b-i)[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(phigh + <span class="string">&quot;0&quot;</span> * (dec_len-<span class="number">6</span>)) * <span class="built_in">int</span>(qhigh + <span class="string">&quot;0&quot;</span> * (dec_len-<span class="number">6</span>)) &lt; n <span class="keyword">and</span> <span class="built_in">int</span>(phigh + <span class="string">&quot;9&quot;</span> * (dec_len-<span class="number">6</span>)) * <span class="built_in">int</span>(qhigh + <span class="string">&quot;9&quot;</span> * (dec_len-<span class="number">6</span>)) &gt; n):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>至此已知条件就成了已知p、q的高六位与低六位(十进制位)和p*q,并且p,q互为逆序，要还原p,q</p><p>搜索方式：从两端向中间搜索，每次搜索有10×10种可能</p><p>剪枝条件：</p><p>p,q未搜索到的位全填0，乘积应该小于n</p><p>p,q未搜索到的位全填9，乘积应该大于n</p><p>p,q低k位的乘积取低k位，应该和n的低k位相同</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">p,q,c,n</span>):</span><br><span class="line">    phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    d = inverse(<span class="number">65537</span>,phi)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">ph,qh,pl,ql</span>):</span><br><span class="line">    <span class="comment">#条件1，2</span></span><br><span class="line">    padding0 = (dec_len-<span class="built_in">len</span>(ph)-<span class="built_in">len</span>(pl))*<span class="string">&quot;0&quot;</span></span><br><span class="line">    padding9 = (dec_len-<span class="built_in">len</span>(ph)-<span class="built_in">len</span>(pl))*<span class="string">&quot;9&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(qh+padding0+ql)*<span class="built_in">int</span>(ph+padding0+pl) &gt; n <span class="keyword">or</span> <span class="built_in">int</span>(qh+padding9+ql)*<span class="built_in">int</span>(ph+padding9+pl) &lt; n):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#条件三</span></span><br><span class="line">    mask = <span class="number">10</span>**<span class="built_in">len</span>(pl)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(ql)*<span class="built_in">int</span>(pl) % mask != n % mask):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="built_in">int</span>(ph+<span class="built_in">str</span>(i)+pl) == <span class="number">0</span>):</span><br><span class="line">            p = <span class="built_in">int</span>(ph+<span class="built_in">str</span>(i)+pl)</span><br><span class="line">            q = n // p</span><br><span class="line">            dec(p,q,c,n)</span><br><span class="line">            exit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#search  </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            find(ph + <span class="built_in">str</span>(i), qh + <span class="built_in">str</span>(j), <span class="built_in">str</span>(j) + pl, <span class="built_in">str</span>(i) + ql)</span><br></pre></td></tr></table></figure><p>好难</p><p>到这步接下来就能得到flag了</p><p>剪枝这一块参照：</p><p> <a href="https://tangcuxiaojikuai.xyz/post/342113ee.html"> Crypto趣题-剪枝 </a></p><p> <a href="https://ech0her.github.io/2024/03/09/Crypto-剪枝/"> Crypto-剪枝 </a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
